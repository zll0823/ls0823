<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"> 
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>2</title>


<style>
body {
	position: absolute;
	margin: 0;
	padding: 0;
	background: #e6cad1;
	width: 100%;
	height: 100%;
	text-align: center;
	color: #FFF;
	}
	
ul.pagination {
    display: inline-block;
    padding: 0;
    margin: 0;
}

ul.pagination li {display: inline;}

ul.pagination li a {
    color: black;
    float: left;
    padding: 8px 16px;
    text-decoration: none;
    border-radius: 5px;
	transition: background .3s;
}

ul.pagination li a.active {
    background: linear-gradient(225deg,#f857a6,#ff5858);
    color: white;
    border-radius: 5px;
}

ul.pagination li a:hover:not(.active) {background-color: #ddd;}	

div.w {
	position: absolute; 
	right: 5%;
	top: 5%}

	
#canvas {
/*   position: absolute;
  top: 0; right: 0; left: 0;
  margin: auto; */
  
	margin: auto;
	margin-bottom: 1em;
	max-width: 100%;
	height: auto;
/* 	background:#000; */
}

*{
  margin: 0;
  padding: 0;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
}

h1{
  font-size: 2.5rem;
  font-family: 'Montserrat';
  font-weight: normal;
  color: #444;
  text-align: center;
  margin: 2rem 0;
}

.wrapper{
  width: 90%;
  margin: 0 auto;
  max-width: 80rem;
}

.cols{
  display: -webkit-box;
  display: -ms-flexbox;
  display: flex;
  -ms-flex-wrap: wrap;
      flex-wrap: wrap;
  -webkit-box-pack: center;
      -ms-flex-pack: center;
          justify-content: center;
}

.col{
  width: calc(25% - 2rem);
  margin: 1rem;
  cursor: pointer;
}

.container{
  -webkit-transform-style: preserve-3d;
          transform-style: preserve-3d;
	-webkit-perspective: 1000px;
	        perspective: 1000px;
}

.front,
.back{
  background-size: cover;
	background-position: center;
	-webkit-transition: -webkit-transform .7s cubic-bezier(0.4, 0.2, 0.2, 1);
	transition: -webkit-transform .7s cubic-bezier(0.4, 0.2, 0.2, 1);
	-o-transition: transform .7s cubic-bezier(0.4, 0.2, 0.2, 1);
	transition: transform .7s cubic-bezier(0.4, 0.2, 0.2, 1);
	transition: transform .7s cubic-bezier(0.4, 0.2, 0.2, 1), -webkit-transform .7s cubic-bezier(0.4, 0.2, 0.2, 1);
	-webkit-backface-visibility: hidden;
	        backface-visibility: hidden;
	text-align: center;
	min-height: 280px;
	height: auto;
	border-radius: 10px;
	color: #fff;
	font-size: 1.5rem;
}

.back{
  background: #cedce7;
  background: -webkit-linear-gradient(45deg,  #cedce7 0%,#596a72 100%);
  background: -o-linear-gradient(45deg,  #cedce7 0%,#596a72 100%);
  background: linear-gradient(45deg,  #cedce7 0%,#596a72 100%);
}

.front:after{
	position: absolute;
    top: 0;
    left: 0;
    z-index: 1;
    width: 100%;
    height: 100%;
    content: '';
    display: block;
    opacity: .6;
    background-color: #000;
    -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
    border-radius: 10px;
}
.container:hover .front,
.container:hover .back{
    -webkit-transition: -webkit-transform .7s cubic-bezier(0.4, 0.2, 0.2, 1);
    transition: -webkit-transform .7s cubic-bezier(0.4, 0.2, 0.2, 1);
    -o-transition: transform .7s cubic-bezier(0.4, 0.2, 0.2, 1);
    transition: transform .7s cubic-bezier(0.4, 0.2, 0.2, 1);
    transition: transform .7s cubic-bezier(0.4, 0.2, 0.2, 1), -webkit-transform .7s cubic-bezier(0.4, 0.2, 0.2, 1);
}

.back{
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
}

.inner{
    -webkit-transform: translateY(-50%) translateZ(60px) scale(0.94);
            transform: translateY(-50%) translateZ(60px) scale(0.94);
    top: 50%;
    position: absolute;
    left: 0;
    width: 100%;
    padding: 2rem;
    -webkit-box-sizing: border-box;
            box-sizing: border-box;
    outline: 1px solid transparent;
    -webkit-perspective: inherit;
            perspective: inherit;
    z-index: 2;
}

.container .back{
    -webkit-transform: rotateY(180deg);
            transform: rotateY(180deg);
    -webkit-transform-style: preserve-3d;
            transform-style: preserve-3d;
}

.container .front{
    -webkit-transform: rotateY(0deg);
            transform: rotateY(0deg);
    -webkit-transform-style: preserve-3d;
            transform-style: preserve-3d;
}

.container:hover .back{
  -webkit-transform: rotateY(0deg);
          transform: rotateY(0deg);
  -webkit-transform-style: preserve-3d;
          transform-style: preserve-3d;
}

.container:hover .front{
  -webkit-transform: rotateY(-180deg);
          transform: rotateY(-180deg);
  -webkit-transform-style: preserve-3d;
          transform-style: preserve-3d;
}

.front .inner p{
  font-size: 2rem;
  margin-bottom: 2rem;
  position: relative;
}

.front .inner p:after{
  content: '';
  width: 4rem;
  height: 2px;
  position: absolute;
  background: #C6D4DF;
  display: block;
  left: 0;
  right: 0;
  margin: 0 auto;
  bottom: -.75rem;
}

.front .inner span{
  color: rgba(255,255,255,0.7);
  font-family: 'Montserrat';
  font-weight: 300;
}

@media screen and (max-width: 64rem){
  .col{
    width: calc(33.333333% - 2rem);
  }
}

@media screen and (max-width: 48rem){
  .col{
    width: calc(50% - 2rem);
  }
}

@media screen and (max-width: 32rem){
  .col{
    width: 100%;
    margin: 0 0 2rem 0;
  }
}

.pt-page-moveToLeft {
                -webkit-animation: moveToLeft .6s ease both;
                -moz-animation: moveToLeft .6s ease both;
                animation: moveToLeft .6s ease both;
            }
            @-webkit-keyframes moveToLeft {
                from{-webkit-transform:translateX(-100%);}
                to { -webkit-transform: translateX(0%); }
            }
            @-moz-keyframes moveToLeft {
                from{-moz-transform:translateX(-100%);}
                to { -moz-transform: translateX(0%); }
            }
            @-o-keyframs moveToLeft{
                from{-o-transform:translateX(-100%);}
                to(-o-transform:translateX(0%);}
            }
            @keyframes moveToLeft {
                form{transform:translateX(-100%);}
                to { transform: translateX(0%); }
            }
			
</style>

</head>
<body>
<div class="pt-page-moveToLeft">

<div class="wrapper">
	<div class="w">
<ul class="pagination">
  <li><a href="../1/1.html">«</a></li>
  <li><a href="../1/1.html">1</a></li>
  <li><a class="active" href="2.html">2</a></li>
  <li><a href="../3/3.html">3</a></li>
  <li><a href="../4/4.html">4</a></li>
  <li><a href="../5/5.html">5</a></li>
  <li><a href="../3/3.html">»</a></li>
</ul>
</div>
   <div class="canvas"><canvas id="canvas" width="900" height="300"></canvas></div>
  <div class="cols">
			<div class="col" ontouchstart="this.classList.toggle('hover');">
				<div class="container">
					<div class="front" style="background-image: url(img/1.jpg);">
						<div class="inner">
							<p>把</p>
              <span>2</span>
						</div>
					</div>
					<div class="back">
						<div class="inner">
						  <p>祝我最最最最最亲爱的老师生日快乐！！<br>ヾ(@^▽^@)ノ</p>
						</div>
					</div>
				</div>
			</div>
			<div class="col" ontouchstart="this.classList.toggle('hover');">
				<div class="container">
					<div class="front" style="background-image:url(img/2.jpg);">
						<div class="inner">
							<p>鼠</p>
              <span>0</span>
						</div>
					</div>
					<div class="back">
						<div class="inner">
							<p>愿您能走遍所有想去的地方。<br>(๑¯∀¯๑)</p>
						</div>
					</div>
				</div>
			</div>
			<div class="col" ontouchstart="this.classList.toggle('hover');">
				<div class="container">
					<div class="front" style="background-image: url(img/3.jpg);">
						<div class="inner">
							<p>标</p>
              <span>1</span>
						</div>
					</div>
					<div class="back">
						<div class="inner">
							<p>愿您能吃遍这世间的美食。<br>١١(❛ัᴗ❛ั⁎)吃吃吃!!</p>
						</div>
					</div>
				</div>
			</div>
			<div class="col" ontouchstart="this.classList.toggle('hover');">
				<div class="container">
					<div class="front" style="background-image: url(img/4.jpg);">
						<div class="inner">
							<p>放</p>
              <span>9</span>
						</div>
					</div>
					<div class="back">
						<div class="inner">
							<p>愿您永远被快乐拥抱，幸福快乐。<br>(⁎˃ᴗ˂⁎)</p>
						</div>
					</div>
				</div>
			</div>
			<div class="col" ontouchstart="this.classList.toggle('hover');">
				<div class="container">
					<div class="front" style="background-image: url(img/5.jpg);">
						<div class="inner">
							<p>上</p>
              <span>0</span>
						</div>
					</div>
					<div class="back">
						<div class="inner">
							<p>愿您身体健康，平安一生。<br>(〃'▽'〃)</p>
						</div>
					</div>
				</div>
			</div>
			<div class="col" ontouchstart="this.classList.toggle('hover');">
				<div class="container">
					<div class="front" style="background-image: url(img/6.jpg);">
						<div class="inner">
							<p>来</p>
              <span>8</span>
						</div>
					</div>
					<div class="back">
						<div class="inner">
							<p>不知道您头疼的毛病有没有好些，要照顾好自己哦。<br>^_^</p>
						</div>
					</div>
				</div>
			</div>
			<div class="col" ontouchstart="this.classList.toggle('hover');">
				<div class="container">
					<div class="front" style="background-image: url(img/7.jpg);">
						<div class="inner">
							<p>哦</p>
              <span>2</span>
						</div>
					</div>
					<div class="back">
						<div class="inner">
							<p>感谢遇见了您，感谢您陪伴了我们三年。<br>感恩(。’▽’。)♡</p>
						</div>
					</div>
				</div>
			</div>
			<div class="col" ontouchstart="this.classList.toggle('hover');">
				<div class="container">
					<div class="front" style="background-image: url(img/8.jpg);">
						<div class="inner">
							<p>^_^</p>
              <span>3</span>
						</div>
					</div>
					<div class="back">
						<div class="inner">
							<p>我一直都在。<br>--郑丽琳<br>(后面多动动鼠标~)</p>
						</div>
					</div>
				</div>
			</div>
		</div>
 </div>
 

<script>
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

console.clear();

var TWOPI = Math.PI * 2;

function distance(x1, y1, x2, y2) {
	var dx = x1 - x2;
	var dy = y1 - y2;
	return Math.sqrt(dx * dx + dy * dy);
}

var gravity = 0.5;

// VNode class

var VNode = function () {
	function VNode(node) {
		_classCallCheck(this, VNode);

		this.x = node.x || 0;
		this.y = node.y || 0;
		this.oldX = this.x;
		this.oldY = this.y;
		this.w = node.w || 2;
		this.angle = node.angle || 0;
		this.gravity = node.gravity || gravity;
		this.mass = node.mass || 1.0;

		this.color = node.color;
		this.letter = node.letter;

		this.pointerMove = node.pointerMove;
		this.fixed = node.fixed;
	}
	// verlet integration


	_createClass(VNode, [{
		key: 'integrate',
		value: function integrate(pointer) {

			if (this.lock && (!this.lockX || !this.lockY)) {
				this.lockX = this.x;
				this.lockY = this.y;
			}

			if (this.pointerMove && pointer && distance(this.x, this.y, pointer.x, pointer.y) < this.w + pointer.w) {
				this.x += (pointer.x - this.x) / (this.mass * 18);
				this.y += (pointer.y - this.y) / (this.mass * 18);
			} else if (this.lock) {
				this.x += (this.lockX - this.x) * this.lock;
				this.y += (this.lockY - this.y) * this.lock;
			}

			if (!this.fixed) {
				var x = this.x;
				var y = this.y;
				this.x += this.x - this.oldX;
				this.y += this.y - this.oldY + this.gravity;
				this.oldX = x;
				this.oldY = y;
			}
		}
	}, {
		key: 'set',
		value: function set(x, y) {
			this.oldX = this.x = x;
			this.oldY = this.y = y;
		}
		// draw node

	}, {
		key: 'draw',
		value: function draw(ctx) {
			if (!this.color) {
				return;
			}
			// ctx.globalAlpha = 0.8;
			ctx.translate(this.x, this.y);
			ctx.rotate(this.angle);
			ctx.fillStyle = this.color;

			ctx.beginPath();
			if (this.letter) {
				ctx.globalAlpha = 1;
				ctx.rotate(Math.PI / 2);

				ctx.rect(-7, 0, 14, 1);

				ctx.textAlign = 'center';
				ctx.textBaseline = 'middle';
				ctx.font = 'bold 75px "Bebas Neue", monospace';
				ctx.fillStyle = '#000';
				ctx.fillText(this.letter, 0, this.w * .25 + 4);

				ctx.fillStyle = this.color;
				ctx.fillText(this.letter, 0, this.w * .25);
			} else {
				ctx.globalAlpha = 0.2;
				ctx.rect(-this.w, -this.w, this.w * 2, this.w * 2);
				// ctx.arc(this.x, this.y, this.w, 0, 2 * Math.PI);
			}
			ctx.closePath();
			ctx.fill();
			ctx.setTransform(1, 0, 0, 1, 0, 0);
		}
	}]);

	return VNode;
}();
// constraint class


var Constraint = function () {
	function Constraint(n0, n1, stiffness) {
		_classCallCheck(this, Constraint);

		this.n0 = n0;
		this.n1 = n1;
		this.dist = distance(n0.x, n0.y, n1.x, n1.y);
		this.stiffness = stiffness || 0.5;
		this.firstRun = true;
	}
	// solve constraint


	_createClass(Constraint, [{
		key: 'solve',
		value: function solve() {
			var dx = this.n0.x - this.n1.x;
			var dy = this.n0.y - this.n1.y;

			var newAngle = Math.atan2(dy, dx);
			this.n1.angle = newAngle;

			var currentDist = distance(this.n0.x, this.n0.y, this.n1.x, this.n1.y);
			var delta = this.stiffness * (currentDist - this.dist) / currentDist;
			dx *= delta;
			dy *= delta;

			if (this.firstRun) {
				this.firstRun = false;
				if (!this.n1.fixed) {
					this.n1.x += dx;
					this.n1.y += dy;
				}
				if (!this.n0.fixed) {
					this.n0.x -= dx;
					this.n0.y -= dy;
				}
				return;
			}

			var m1 = this.n0.mass + this.n1.mass;
			var m2 = this.n0.mass / m1;
			m1 = this.n1.mass / m1;

			if (!this.n1.fixed) {
				this.n1.x += dx * m2;
				this.n1.y += dy * m2;
			}
			if (!this.n0.fixed) {
				this.n0.x -= dx * m1;
				this.n0.y -= dy * m1;
			}
		}
		// draw constraint

	}, {
		key: 'draw',
		value: function draw(ctx) {
			ctx.globalAlpha = 0.9;
			ctx.beginPath();
			ctx.moveTo(this.n0.x, this.n0.y);
			ctx.lineTo(this.n1.x, this.n1.y);
			ctx.strokeStyle = "#fff";
			ctx.stroke();
		}
	}]);

	return Constraint;
}();

var Rope = function () {
	function Rope(rope) {
		_classCallCheck(this, Rope);

		var x = rope.x,
		    y = rope.y,
		    length = rope.length,
		    points = rope.points,
		    vertical = rope.vertical,
		    fixedEnds = rope.fixedEnds,
		    startNode = rope.startNode,
		    letter = rope.letter,
		    endNode = rope.endNode,
		    stiffness = rope.stiffness,
		    constrain = rope.constrain,
		    gravity = rope.gravity,
		    pointerMove = rope.pointerMove;


		this.stiffness = stiffness || 1;
		this.nodes = [];
		this.constraints = [];
		if (letter === ' ') {
			return this;
		}

		var dist = length / points;

		for (var i = 0, _last = points - 1; i < points; i++) {

			var size = letter && i === _last ? 15 : 2;
			var spacing = dist * i + size;
			var node = new VNode({
				w: size,
				mass: .1, //(i === last ? .5 : .1),
				fixed: fixedEnds && (i === 0 || i === _last)
			});

			node = i === 0 && startNode || i === _last && endNode || node;

			node.gravity = gravity;
			//node.pointerMove = pointerMove;

			if (i === _last && letter) {
				node.letter = letter;
				node.color = '#FFF';
				node.pointerMove = true;
			}

			node.oldX = node.x = x + (!vertical ? spacing : 0);
			node.oldY = node.y = y + (vertical ? spacing : 0);

			this.nodes.push(node);
		}

		constrain ? this.makeConstraints() : null;
	}

	_createClass(Rope, [{
		key: 'makeConstraints',
		value: function makeConstraints() {
			for (var i = 1; i < this.nodes.length; i++) {
				this.constraints.push(new Constraint(this.nodes[i - 1], this.nodes[i], this.stiffness));
			}
		}
	}, {
		key: 'run',
		value: function run(pointer) {
			// integration
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = this.nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var n = _step.value;

					n.integrate(pointer);
				}
				// solve constraints
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			for (var i = 0; i < 5; i++) {
				var _iteratorNormalCompletion2 = true;
				var _didIteratorError2 = false;
				var _iteratorError2 = undefined;

				try {
					for (var _iterator2 = this.constraints[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
						var _n = _step2.value;

						_n.solve();
					}
				} catch (err) {
					_didIteratorError2 = true;
					_iteratorError2 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion2 && _iterator2.return) {
							_iterator2.return();
						}
					} finally {
						if (_didIteratorError2) {
							throw _iteratorError2;
						}
					}
				}
			}
		}

		// draw(ctx) {
		//   // draw constraints
		//   this.constraints.forEach(n => {
		//     n.draw(ctx);
		//   });
		//   // draw nodes
		//   this.nodes.forEach(n => {
		//     n.draw(ctx);
		//   })
		// }

	}, {
		key: 'draw',
		value: function draw(ctx) {

			var vertices = Array.from(this.constraints).reduce(function (p, c, i, a) {
				p.push(c.n0);
				if (i == a.length - 1) p.push(c.n1);
				return p;
			}, []);

			var h = function h(x, y) {
				return Math.sqrt(x * x + y * y);
			};
			var tension = 0.5;

			if (!vertices.length) return;

			var controls = vertices.map(function () {
				return null;
			});
			for (var i = 1; i < vertices.length - 1; ++i) {
				var previous = vertices[i - 1];
				var current = vertices[i];
				var next = vertices[i + 1];

				var rdx = next.x - previous.x,
				    rdy = next.y - previous.y,
				    rd = h(rdx, rdy),
				    dx = rdx / rd,
				    dy = rdy / rd;

				var dp = h(current.x - previous.x, current.y - previous.y),
				    dn = h(current.x - next.x, current.y - next.y);

				var cpx = current.x - dx * dp * tension,
				    cpy = current.y - dy * dp * tension,
				    cnx = current.x + dx * dn * tension,
				    cny = current.y + dy * dn * tension;

				controls[i] = {
					cp: {
						x: cpx,
						y: cpy
					},
					cn: {
						x: cnx,
						y: cny
					}
				};
			}

			controls[0] = {
				cn: {
					x: (vertices[0].x + controls[1].cp.x) / 2,
					y: (vertices[0].y + controls[1].cp.y) / 2
				}
			};

			controls[vertices.length - 1] = {
				cp: {
					x: (vertices[vertices.length - 1].x + controls[vertices.length - 2].cn.x) / 2,
					y: (vertices[vertices.length - 1].y + controls[vertices.length - 2].cn.y) / 2
				}
			};

			// Draw vertices & control points
			// ctx.fillStyle = 'blue';
			// ctx.fillRect(vertices[0].x, vertices[0].y, 4, 4);
			// for (let i = 1; i < vertices.length; ++i)
			// {
			// 	const v = vertices[i];
			// 	const ca = controls[i - 1];
			// 	const cb = controls[i];
			// 	ctx.fillStyle = 'blue';
			// 	ctx.fillRect(v.x, v.y, 4, 4);
			// 	ctx.fillStyle = 'green';
			// 	ctx.fillRect(ca.cn.x, ca.cn.y, 4, 4);
			// 	ctx.fillRect(cb.cp.x, cb.cp.y, 4, 4);
			// }

			ctx.globalAlpha = 0.9;
			ctx.beginPath();
			ctx.moveTo(vertices[0].x, vertices[0].y);
			for (var _i = 1; _i < vertices.length; ++_i) {
				var v = vertices[_i];
				var ca = controls[_i - 1];
				var cb = controls[_i];

				ctx.bezierCurveTo(ca.cn.x, ca.cn.y, cb.cp.x, cb.cp.y, v.x, v.y);
			}
			ctx.strokeStyle = 'white';
			ctx.stroke();
			ctx.closePath();

			// draw nodes
			this.nodes.forEach(function (n) {
				n.draw(ctx);
			});
		}
	}]);

	return Rope;
}();

// Pointer class


var Pointer = function (_VNode) {
	_inherits(Pointer, _VNode);

	function Pointer(canvas) {
		_classCallCheck(this, Pointer);

		var _this = _possibleConstructorReturn(this, (Pointer.__proto__ || Object.getPrototypeOf(Pointer)).call(this, {
			x: 0,
			y: 0,
			w: 8,
			color: '#F00',
			fixed: true
		}));

		_this.elem = canvas;
		canvas.addEventListener("mousemove", function (e) {
			return _this.move(e);
		}, false);
		canvas.addEventListener("touchmove", function (e) {
			return _this.move(e);
		}, false);
		return _this;
	}

	_createClass(Pointer, [{
		key: 'move',
		value: function move(e) {
			var touchMode = e.targetTouches;
			var pointer = e;
			if (touchMode) {
				e.preventDefault();
				pointer = touchMode[0];
			}
			var rect = this.elem.getBoundingClientRect();
			var cw = this.elem.width;
			var ch = this.elem.height;

			// get the scale based on actual width;
			var sx = cw / this.elem.offsetWidth;
			var sy = ch / this.elem.offsetHeight;

			this.x = (pointer.clientX - rect.left) * sx;
			this.y = (pointer.clientY - rect.top) * sy;
		}
	}]);

	return Pointer;
}(VNode);

var Scene = function () {
	function Scene(canvas) {
		_classCallCheck(this, Scene);

		this.draw = true;
		this.canvas = canvas;
		this.ctx = canvas.getContext('2d');

		this.nodes = new Set();
		this.constraints = new Set();
		this.ropes = [];

		this.pointer = new Pointer(canvas);
		this.nodes.add(this.pointer);

		this.run = this.run.bind(this);
		this.addRope = this.addRope.bind(this);
		this.add = this.add.bind(this);
	}

	// animation loop


	_createClass(Scene, [{
		key: 'run',
		value: function run() {
			var _this2 = this;

			// if (!canvas.isConnected) {
			//   return;
			// }
			requestAnimationFrame(this.run);
			// clear screen
			this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

			this.ropes.forEach(function (rope) {
				rope.run(_this2.pointer);
			});

			this.ropes.forEach(function (rope) {
				rope.draw(_this2.ctx);
			});

			// // integration
			// for (let n of nodes) {
			//   n.integrate(pointer);
			// }
			// solve constraints
			// for (let i = 0; i < 4; i++) {
			//   for (let n of constraints) {
			//     n.solve();
			//   }
			// }
			// // draw constraints
			// for (let n of constraints) {
			//   n.draw(ctx);
			// }
			// draw nodes
			var _iteratorNormalCompletion3 = true;
			var _didIteratorError3 = false;
			var _iteratorError3 = undefined;

			try {
				for (var _iterator3 = this.nodes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
					var n = _step3.value;

					n.draw(this.ctx);
				}
			} catch (err) {
				_didIteratorError3 = true;
				_iteratorError3 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion3 && _iterator3.return) {
						_iterator3.return();
					}
				} finally {
					if (_didIteratorError3) {
						throw _iteratorError3;
					}
				}
			}
		}
	}, {
		key: 'addRope',
		value: function addRope(rope) {
			this.ropes.push(rope);
		}
	}, {
		key: 'add',
		value: function add(struct) {

			// load nodes
			for (var n in struct.nodes) {
				this.nodes.add(struct.nodes[n]);
				/*
       const node = new Node(struct.nodes[n]);
       struct.nodes[n].id = node;
       nodes.add(node);
       */
			}

			// load constraints
			for (var i = 0; i < struct.constraints.length; i++) {
				var c = struct.constraints[i];
				this.constraints.add(c);
				/*
       	new Constraint(
       		struct.nodes[c[0]].id,
       		struct.nodes[c[1]].id
       	)
       );
       */
			}
		}
	}]);

	return Scene;
}();

var scene = new Scene(document.querySelector('#canvas'));

scene.run();

// const pointer = new Pointer(canvas);

var phrase = ' HAPPY Birthday ';

var r = new Rope({
	x: scene.canvas.width * 0.15,
	y: 40,
	length: scene.canvas.width * 0.7,
	points: phrase.length,
	vertical: false,
	dangleEnd: false,
	fixedEnds: true,
	stiffness: 1.5,
	constrain: false,
	gravity: 0.1
});

var center = r.nodes.length / 2;

var ropes = r.nodes.map(function (n, i) {

	n.set(n.x, 60 + 80 * (1 - Math.abs((center - i) % center / center)));

	if (phrase[i] !== ' ') {

		//if ( i !== 0 && i !== r.nodes.length - 1 ) {
		return new Rope({
			startNode: n,
			x: n.x,
			y: n.y,
			length: 60,
			points: 4,
			letter: phrase[i],
			vertical: true,
			stiffness: 1, //2.5,,
			constrain: false,
			gravity: 0.5
		});
	}

	//}
});

var first = r.nodes[0];
var last = r.nodes[r.nodes.length - 1];

first.set(2, -2);
last.set(scene.canvas.width - 2, -2);

r.makeConstraints();

ropes = ropes;
scene.addRope(r);
ropes.filter(function (r) {
	return r;
}).forEach(function (r) {
	r.makeConstraints();
	scene.addRope(r);
});</script>
</div>
</body>
</html>
